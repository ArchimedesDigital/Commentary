import baseTheme from 'material-ui/styles/baseThemes/lightBaseTheme';
import getMuiTheme from 'material-ui/styles/getMuiTheme';
import IconButton from 'material-ui/IconButton';
import FlatButton from 'material-ui/FlatButton';
import RaisedButton from 'material-ui/RaisedButton';
import InfiniteScroll from '../../../imports/InfiniteScroll';
import { ReactiveVar } from 'meteor/reactive-var'

ContextReader = React.createClass({

<<<<<<< HEAD
		getChildContext() {
				return {
						muiTheme: getMuiTheme(baseTheme)
				};
		},

		childContextTypes: {
				muiTheme: React.PropTypes.object.isRequired
		},

		propTypes: {
				workSlug: React.PropTypes.string.isRequired,
				subwork_n: React.PropTypes.number.isRequired,
				selectedLineFrom: React.PropTypes.number.isRequired,
				selectedLineTo: React.PropTypes.number.isRequired,
				updateSelecetedLines: React.PropTypes.func.isRequired,
				// initLineFrom: React.PropTypes.number.isRequired,
				// initLineTo: React.PropTypes.number.isRequired,
				// initHighlightLineFrom: React.PropTypes.number,
				// initHighlightLineTo: React.PropTypes.number,
				// commentGroup: React.PropTypes.object.isRequired,
				// closeContextPanel: React.PropTypes.func.isRequired,
		},

		getInitialState() {
				return {
						lineFrom: 1,
						lineTo: 50,
						selectedLemmaEdition : "",
						// selectedLineFrom: 0,
						// selectedLineTo: 0,
				};
		},
=======
    getChildContext() {
        return {
            muiTheme: getMuiTheme(baseTheme)
        };
    },

    childContextTypes: {
        muiTheme: React.PropTypes.object.isRequired
    },

    propTypes: {
        open: React.PropTypes.bool.isRequired,
        contextReaderOpen: React.PropTypes.func.isRequired,

        workSlug: React.PropTypes.string.isRequired,
        subwork_n: React.PropTypes.number.isRequired,
        selectedLineFrom: React.PropTypes.number.isRequired,
        selectedLineTo: React.PropTypes.number.isRequired,
        updateSelecetedLines: React.PropTypes.func.isRequired,
        // initLineFrom: React.PropTypes.number.isRequired,
        // initLineTo: React.PropTypes.number.isRequired,
        // initHighlightLineFrom: React.PropTypes.number,
        // initHighlightLineTo: React.PropTypes.number,
        // commentGroup: React.PropTypes.object.isRequired,
        // closeContextPanel: React.PropTypes.func.isRequired,
    },

    getInitialState() {
        return {
            lineFrom: 1,
            lineTo: 50,
            selectedLemmaEdition : "",
            // selectedLineFrom: 0,
            // selectedLineTo: 0,
        };
    },
>>>>>>> feature/add-comments

	componentDidUpdate(prevProps, prevState) {
				// this.checkIfPropsChanged();
				// this.checkIfStateChanged();


				if (this.props.selectedLineFrom === 0) {
						for (var i = 1; i <= Object.keys(this.refs).length; i++) {
								this.refs[i.toString()].style.borderBottom = "1px solid #ffffff";
						};
				} else if (this.props.selectedLineTo === 0) {
						for (var i = 1; i <= Object.keys(this.refs).length; i++) {
								if (i === this.props.selectedLineFrom) {
										this.refs[i.toString()].style.borderBottom = "1px solid #d59518";
								} else {
										this.refs[i.toString()].style.borderBottom = "1px solid #ffffff";
								};
						};
				} else {
						for (var i = 1; i <= Object.keys(this.refs).length; i++) {
								if (i >= this.props.selectedLineFrom && i <= this.props.selectedLineTo) {
										this.refs[i.toString()].style.borderBottom = "1px solid #d59518";
								} else {
										this.refs[i.toString()].style.borderBottom = "1px solid #ffffff";
								};
						};
				}
	},


<<<<<<< HEAD
		mixins: [ReactMeteorData],

		getMeteorData() {

				var that = this;

				var lemmaText = [];
				// var commentGroup = this.props.commentGroup;
				var selectedLemmaEdition = {
						lines: [],
						slug: ""
				};

				var lemmaQuery = {
						'work.slug': this.props.workSlug,
						'subwork.n': this.props.subwork_n,
						'text.n': {
								$gte: this.state.lineFrom,
								$lte: this.state.lineTo
						}
				};

				var textNodesSubscription = Meteor.subscribe('textNodes', lemmaQuery);
				if (textNodesSubscription.ready()) {
						//console.log("Context Panel lemmaQuery", lemmaQuery);
						var textNodes = TextNodes.find(lemmaQuery).fetch();
						var editions = [];

						var textIsInEdition = false;
						textNodes.forEach(function(textNode) {

								textNode.text.forEach(function(text) {
										textIsInEdition = false;

										editions.forEach(function(edition) {

												if (text.edition.slug === edition.slug) {
														edition.lines.push({
																html: text.html,
																n: text.n
														});
														textIsInEdition = true;
												}
										})

										if (!textIsInEdition) {
												editions.push({
														title: text.edition.title,
														slug: text.edition.slug,
														lines: [{
																html: text.html,
																n: text.n
														}],
												})
										}
								});
						});

						lemmaText = editions;
						console.log('lemmaText',lemmaText);

						if (this.state.selectedLemmaEdition.length) {
								lemmaText.forEach(function(edition) {
										if (edition.slug === that.state.selectedLemmaEdition) {
												selectedLemmaEdition = edition;
										}
								});
						} else {
								selectedLemmaEdition = lemmaText[0];
						}

				}

				//console.log("Context Panel lemmaText", lemmaText);


				return {
						lemmaText: lemmaText,
						selectedLemmaEdition: selectedLemmaEdition
				};


		},

		toggleEdition(editionSlug) {
				if (this.state.selectedLemmaEdition !== editionSlug) {
						this.setState({
								selectedLemmaEdition: editionSlug
						});
				}
		},

		handeLineMouseEnter(event) {
				var style = event.target.style;
				style.backgroundColor = "#d59518";
		},

		handeLineMouseLeave(event) {
				var style = event.target.style;
				style.backgroundColor = "#ffffff";
		},

		handleLineClick(event) {
				var target = event.target;
				var style = event.target.style;
				var id = parseInt(target.id);
				if (this.props.selectedLineFrom === 0) {
						this.props.updateSelecetedLines(id, null);
				} else if (id === this.props.selectedLineFrom && this.props.selectedLineTo === 0) {
						this.props.updateSelecetedLines(0, null);
				} else if (this.props.selectedLineTo === 0 && id > this.props.selectedLineFrom) {
						this.props.updateSelecetedLines(null, id);
				} else if (this.props.selectedLineTo === 0 && id < this.props.selectedLineFrom) {
						this.props.updateSelecetedLines(id, this.props.selectedLineFrom);
				} else {
						this.props.updateSelecetedLines(id, 0);
				};
		},

		render() {
=======
    mixins: [ReactMeteorData],

    getMeteorData() {

        var that = this;

        if (this.props.workSlug != "" && this.props.subwork_n != 0) {

            var lemmaText = [];
            // var commentGroup = this.props.commentGroup;
            var selectedLemmaEdition = {
                lines: [],
                slug: ""
            };

            var lemmaQuery = {
                'work.slug': this.props.workSlug,
                'subwork.n': this.props.subwork_n,
                'text.n': {
                    $gte: this.state.lineFrom,
                    $lte: this.state.lineTo
                }
            };

            var textNodesSubscription = Meteor.subscribe('textNodes', lemmaQuery);
            if (textNodesSubscription.ready()) {
                //console.log("Context Panel lemmaQuery", lemmaQuery);
                var textNodes = TextNodes.find(lemmaQuery).fetch();
                var editions = [];

                var textIsInEdition = false;
                textNodes.forEach(function(textNode) {

                    textNode.text.forEach(function(text) {
                        textIsInEdition = false;

                        editions.forEach(function(edition) {

                            if (text.edition.slug === edition.slug) {
                                edition.lines.push({
                                    html: text.html,
                                    n: text.n
                                });
                                textIsInEdition = true;
                            }
                        })

                        if (!textIsInEdition) {
                            editions.push({
                                title: text.edition.title,
                                slug: text.edition.slug,
                                lines: [{
                                    html: text.html,
                                    n: text.n
                                }],
                            })
                        }
                    });
                });

                lemmaText = editions;
                // console.log('lemmaText',lemmaText);

                if (this.state.selectedLemmaEdition.length) {
                    lemmaText.forEach(function(edition) {
                        if (edition.slug === that.state.selectedLemmaEdition) {
                            selectedLemmaEdition = edition;
                        }
                    });
                } else {
                    selectedLemmaEdition = lemmaText[0];
                }

            }

            //console.log("Context Panel lemmaText", lemmaText);


            return {
                lemmaText: lemmaText,
                selectedLemmaEdition: selectedLemmaEdition
            };
        } else {
            return {
                lemmaText: "",
                selectedLemmaEdition: ""
            };
        };
    },

    toggleEdition(editionSlug) {
        if (this.state.selectedLemmaEdition !== editionSlug) {
            this.setState({
                selectedLemmaEdition: editionSlug
            });
        }
    },

    handeLineMouseEnter(event) {
        var style = event.target.style;
        style.backgroundColor = "#d59518";
    },

    handeLineMouseLeave(event) {
        var style = event.target.style;
        style.backgroundColor = "#ffffff";
    },

    handleLineClick(event) {
        var target = event.target;
        var style = event.target.style;
        var id = parseInt(target.id);
        if (this.props.selectedLineFrom === 0) {
            this.props.updateSelecetedLines(id, null);
        } else if (id === this.props.selectedLineFrom && this.props.selectedLineTo === 0) {
            this.props.updateSelecetedLines(0, null);
        } else if (this.props.selectedLineTo === 0 && id > this.props.selectedLineFrom) {
            this.props.updateSelecetedLines(null, id);
        } else if (this.props.selectedLineTo === 0 && id < this.props.selectedLineFrom) {
            this.props.updateSelecetedLines(id, this.props.selectedLineFrom);
        } else {
            this.props.updateSelecetedLines(id, 0);
        };
    },

    render() {
>>>>>>> feature/add-comments
		var self = this;
		var contextPanelStyles = "lemma-panel paper-shadow";

		if(this.props.open){
			contextPanelStyles += " extended";
		}

<<<<<<< HEAD
				return (
					<div className={contextPanelStyles}>

						<div className="lemma-text-wrap">
								{this.data.selectedLemmaEdition.lines.map(function(line, i){
										var lineClass="lemma-line";

										return <div className={lineClass} key={i}>

												<div className="lemma-meta">
														{(line.n % 5 === 0) ?
																<span className="lemma-line-n">
																		{line.n}
																</span>
														: ""}
												</div>

												<div className="lemma-text" ref={i+1} id={i+1} dangerouslySetInnerHTML={{__html: line.html}} onMouseEnter={self.handeLineMouseEnter} onMouseLeave={self.handeLineMouseLeave} onClick={self.handleLineClick} style={{cursor: "pointer"}}>
												</div>

										</div>

								})}

								<div className="read-more-link">
										<RaisedButton
												className="cover-link light show-more "
												label="Read More"
												onClick={this.readMoreClicked}
										/>
								</div>

						</div>

						<div className="edition-tabs tabs">
								{this.data.lemmaText.map(function(lemmaTextEdition, i){
										let lemmaEditionTitle = Utils.trunc(lemmaTextEdition.title, 20);

										return (
												<RaisedButton
														key={i}
														label={lemmaEditionTitle}
														data-edition={lemmaTextEdition.title}
														className={self.data.selectedLemmaEdition.slug ===	lemmaTextEdition.slug ? "edition-tab tab selected-edition-tab" : "edition-tab tab"}
														onClick={self.toggleEdition.bind(null, lemmaTextEdition.slug)}
												/>
										);

								})}

						</div>
=======
        return (
            <div>
                {this.props.workSlug != "" && this.props.subwork_n != 0 ?
                    
                    <div className={contextPanelStyles}>

                        <IconButton
                            className="close-lemma-panel"
                            onClick={this.props.closeContextPanel}
                            iconClassName="mdi mdi-close"
                        />

                        <div className="lemma-text-wrap">
                            {this.data.selectedLemmaEdition.lines.map(function(line, i){
                                var lineClass="lemma-line";

                                return <div className={lineClass} key={i}>

                                    <div className="lemma-meta">
                                        {(line.n % 5 === 0) ?
                                            <span className="lemma-line-n">
                                                {line.n}
                                            </span>
                                        : ""}
                                    </div>

                                    <div className="lemma-text" ref={i+1} id={i+1} dangerouslySetInnerHTML={{__html: line.html}} onMouseEnter={self.handeLineMouseEnter} onMouseLeave={self.handeLineMouseLeave} onClick={self.handleLineClick} style={{cursor: "pointer"}}>
                                    </div>

                                </div>

                            })}

                            <div className="read-more-link">
                                <RaisedButton
                                    className="cover-link light show-more "
                                    label="Read More"
                                    onClick={this.readMoreClicked}
                                />
                            </div>

                        </div>

                        <div className="edition-tabs tabs">
                            {this.data.lemmaText.map(function(lemmaTextEdition, i){
                                let lemmaEditionTitle = Utils.trunc(lemmaTextEdition.title, 20);
                                
                                return (
                                    <RaisedButton
                                        key={i}
                                        label={lemmaEditionTitle}
                                        data-edition={lemmaTextEdition.title}
                                        className={self.data.selectedLemmaEdition.slug ===  lemmaTextEdition.slug ? "edition-tab tab selected-edition-tab" : "edition-tab tab"}
                                        onClick={self.toggleEdition.bind(null, lemmaTextEdition.slug)}
                                    />
                                );

                            })}

                        </div>

                    </div>

                :
                    <div className={contextPanelStyles}>
                        <IconButton
                            className="close-lemma-panel"
                            onClick={this.props.closeContextPanel}
                            iconClassName="mdi mdi-close"
                        />
                        <div className="lemma-text-wrap">
                            No work & book selected
                        </div>
                    </div>
                }

            </div>
>>>>>>> feature/add-comments

				</div>

				);
		}

});
